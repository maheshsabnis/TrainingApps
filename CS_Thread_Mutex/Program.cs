using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using System.IO;
using System.Diagnostics;
namespace CS_Thread_Mutex
{
	class Program
	{
		// define a Mutex object
		private static Mutex mutex = new Mutex();

		static void Main(string[] args)
		{
			
			for (int i = 0; i < 10; i++)
			{
				Thread thread = new Thread(ConcurrectAccess);
				thread.Name = $"Current Accessing Thread {i}";
				thread.Start();
			}
			
			Console.ReadLine();
		}


		static void ConcurrectAccess()
		{
			Console.WriteLine($"The Thread that wants to enter in the resource is {Thread.CurrentThread.Name} ");
			try
			{
				Stopwatch stopwatch = Stopwatch.StartNew();
				// block the current thread until its execution and signal generated by the thraed
				mutex.WaitOne();
				Console.WriteLine($"Current Thread is processing some data {Thread.CurrentThread.Name}");


				using (Stream stream = new FileStream(@"c:\myfile1.txt", FileMode.Append, FileAccess.Write))
				{
					var sw = new StreamWriter(stream);
					sw.WriteLine($"Written by {Thread.CurrentThread.Name}");
					Console.WriteLine("Data is Written");
					sw.Close();
				}


				//Thread.Sleep(2000);
				Console.WriteLine($"Current Thread {Thread.CurrentThread.Name} is exting");
				stopwatch.Stop();
				Console.WriteLine($"Total time for execution in missliconds  {stopwatch.ElapsedMilliseconds}");
			}
			 
			finally
			{
				// release the thread so that other thread an enter to acess the resource
			 	mutex.ReleaseMutex();
			}
		}
	}
}
